package icondata

import (
	"encoding/binary"
	"bytes"
	"image"
	"image/color"
	"testing"
)

func generateTestImage() image.Image {
	width := 32
	height := 32

	dest := image.NewRGBA(image.Rect(0, 0, width, height))
	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			n := uint8((x * 8) ^ (y * 8))
			c := color.RGBA{n, n, n, 255}
			dest.Set(x, y, c)
		}
	}

	return dest
}

func TestEncodeErrors(t *testing.T) {
	err := Encode(nil, nil)
	m := "image is nil"
	if err.Error() != m {
		t.Errorf("expected error as %v, got %v", m, err)
	}

	tmp := image.NewRGBA(image.Rect(0, 0, 8, 8))
	err = Encode(nil, tmp)
	m = "image too small"
	if err.Error() != m {
		t.Errorf("expected error as %v, got %v", m, err)
	}
}

func TestEncode(t *testing.T) {
	b := new(bytes.Buffer)
	img := generateTestImage()

	err := Encode(b, img)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	result := b.Bytes()

	expected := []byte{
		0x67, 0x6f, 0x2d, 0x69, 0x63, 0x6f, 0x6e, 0x64, 
		0x61, 0x74, 0x61, 0x20, 0x70, 0x6b, 0x67, 0x21, 
		0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 
	}

	s1 := len(expected)
	s2 := len(result)
	if s1 != s2 {
		t.Errorf("expected file size as %v got %v", s1, s2)
	}

	//check header
	d1 := string(expected[:16])
	d2 := string(result[:16])
	if d1 != d2 {
		t.Errorf("expected description as %v got %v", d1, d2)
	}

	o1 := int(binary.LittleEndian.Uint32(expected[16:20]))
	o2 := int(binary.LittleEndian.Uint32(result[16:20]))
	if o1 != o2 {
		t.Errorf("expected mono offset as %v got %v", o1, o2)
	}

	//check pixel data
	for i := 24; i < s1; i++ {
		c1 := result[i]
		c2 := expected[i]

		if c1 != c2 {
			t.Errorf("expected pixel as %v got %v", c1, c2)
		}
	}
}

func TestDecodeErrors(t *testing.T) {
	_, _, err := Decode(nil)
	m := "reader is nil"
	if err.Error() != m {
		t.Errorf("expected error: %v, got %v", m, err)
	}

	for id, tt := range []struct {
		corrupt []byte
		message string
	}{
		{
			//corrupt file
			[]byte{
				0x6d, 0x61, 0x64, 0x65,
			},
			"could not read header",
		},
		{
			//offset less than 24
			[]byte{
				0x6d, 0x61, 0x64, 0x65, 0x20, 0x77, 0x69, 0x74,
				0x68, 0x20, 0x67, 0x6f, 0x76, 0x6d, 0x75, 0x21,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			"mono offset out of bounds",
		},
		{
			//offset larger than 1024 - 24
			[]byte{
				0x6d, 0x61, 0x64, 0x65, 0x20, 0x77, 0x69, 0x74,
				0x68, 0x20, 0x67, 0x6f, 0x76, 0x6d, 0x75, 0x21,
				0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
			},
			"mono offset out of bounds",
		},
		{
			//offset larger than file
			[]byte{
				0x6d, 0x61, 0x64, 0x65, 0x20, 0x77, 0x69, 0x74,
				0x68, 0x20, 0x67, 0x6f, 0x76, 0x6d, 0x75, 0x21,
				0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			"EOF",
		},
		{
			//offset larger than file
			[]byte{
				0x6d, 0x61, 0x64, 0x65, 0x20, 0x77, 0x69, 0x74,
				0x68, 0x20, 0x67, 0x6f, 0x76, 0x6d, 0x75, 0x21,
				0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00,
			},
			"could not read mono bitmap",
		},
	} {
		r := bytes.NewReader(tt.corrupt)
		_, _, err = Decode(r)
		if err.Error() != tt.message {
			t.Errorf("test %v: expected error as %v, got %v", id, tt.message, err)
		}
	}
}

func TestDecode(t *testing.T) {
	img := generateTestImage()
	file := []byte{
		0x6d, 0x61, 0x64, 0x65, 0x20, 0x77, 0x69, 0x74,
		0x68, 0x20, 0x67, 0x6f, 0x76, 0x6d, 0x75, 0x21,
		0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
		0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
	}

	r := bytes.NewReader(file)
	desc, result, err := Decode(r)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	m := "made with govmu!"
	if desc != m {
		t.Errorf("expected description as %v got %v", m, desc)
	}

	bounds := img.Bounds()
	w1 := bounds.Dx()
	h1 := bounds.Dy()

	bounds = result.Bounds()
	w2 := bounds.Dx()
	h2 := bounds.Dy()

	if w1 != w2 {
		t.Errorf("expected width as %v got %v", w1, w2)
	}

	if h1 != h2 {
		t.Errorf("expected height as %v got %v", h1, h2)
	}

	for x := 0; x < w1; x++ {
		for y := 0; y < h1; y++ {
			r, g, b, a := result.At(x, y).RGBA()
			r2, _, _, _ := img.At(x, y).RGBA()

			p := y*w1 + x
			if r != g || r != b {
				t.Errorf("expected pixel %v rgb values to be identical", p)
			}

			if a>>8 != 255 {
				t.Errorf("expected pixel %v alpha value to be 255 got %v", p, a)
			}

			r = r >> 8
			if r > 0 && r < 255 {
				t.Errorf("expected pixel %v value to be either 0 or 255 but got %v", p, r)
			}

			r2 = r2 >> 8
			if r2 < 128 {
				r2 = 0
			} else {
				r2 = 255
			}

			if r != r2 {
				t.Errorf("expected pixel %v value to be %v got %v", p, r2, r)
			}
		}
	}
}
